# 6장 도메인 이벤트와 전술적 설계

도메인 이벤트는 전략적 설계를 위해 매우 중요한 도구로써, 바운디드 컨텍스트 내의 비즈니스 관점에서 중요한 사항들에 대한 기록이다.

그뿐만 아니라 종종 전술적 설계를 하는 동안 도메인 이벤트의 개념이 정립되면서 핵심 도메인의 일부가 된다.

### 인과관계 일관성

인과관계 일관성이라는 개념을 통해 도메인 이벤트의 장점을 살펴보자.

비즈니스 도메인은 인과관계가 있는 오퍼레이션이 분산된 시스템의 동일한 요청 내에 존재하는 모든 의존적인 노드들에게 보여지는 경우, 의존관계 일관성을 제공한다.

오퍼레이션은 반드시 특정한 요청으로 인해 발생하기 때문에 그 특정한 요청이 발생되지 않으면 인과관계에 있는 오퍼레이션은 발생할 수 없다. 즉, 특정한 오퍼레이션이 다른 애그리게잇에서 명확하게 발생하기 전에는 한 애그리게잇이 생성되거나 수정될 수 없다는 의미다.

전술적 설계 노력을 통해 도메인 이벤트가 도메인 모델에 구체화되고, 도메인 이벤트가 만들어지면 바운디드 컨텍스트와 다른 자원들은 이벤트를 받아 활용한다. 이는 중요한 이벤트에 관심이 있는 이벤트 리스너들에게 관련 상황의 발생을 알리는 매우 강력한 방법이다.

## 도메인 이벤트를 설계, 구현, 사용하기

바운디드 컨텍스트 내에 도메인 이벤트를 효과적으로 설계하고 구현하는 데 필요한 지침을 단계별로 살펴보자.

### 도메인 이벤트 모델 이름

우선 도메인 이벤트 세부 사항엔 이벤트 발생 시간이 매우 중요하다. 

꼭 필요한 것은 아니지만, 유용하게 쓸 수 있는 상황이 자주 있으며, 일반적인 도메인 이벤트 형태엔 발생 시간을 갖는다.

도메인 이벤트 이름엔 도메인 모델의 보편 언어를 반영해야 한다. 보편언어를 활영하여 모델들이 원활히 의사소통하는 데 필수적인 역할을 한다.

- ProductCreated
- SpringScheduled
- ReleaseScheduled
- BacklogItemPlanned
- BacklogItemCommited

이벤트란 과거에 발생한 일련의 사건을 뜻함으로 이름은 과거 시제로 명시한다. 발생한 사건을 명시하여 핵심 도메인에서 발생한 사건을 명확하고 간결히 서술해야 한다.

### 도메인 이벤트 모델 프로퍼티

도메인 모델에서 발생한 사건의 기록을 온전히 전달하려면 `도메인 이름`과 `프로퍼티`가 모두 필요하다.

- 식별자
- 엔티티 생성에 있어 필수적인(not null) 프로퍼티 

간혹 도메인 이벤트 모델엔 풍부한 추가적인 데이터를 담고 있을 수 있다. 이는 다시 조회 쿼리를 하지 않는다는 장점이 존재한다. 

하지만 도메인 이벤트에 그 의미를 잃을 정도로 너무 많은 데이터를 가득 채우는 일이 없도록 주의해야 한다. 많은 추가 데이터는 오히려 도메인 이벤트 모델을 이해하기 어렵게 만들 수 있다. 이벤트가 발생하여 어떤 상태가 변경됐는지 명확하게 파악하기 어렵고 그 의미가 모호해진다.

### 도메인 이벤트 인과관계

도메인 이벤트를 이벤트 리파지토리에 관리하는 것은 도메인 모델간에 발생한 것에 대한 인과관계의 순서를 지속시켜준다.

저장된 도메인 이벤트는 구독하고 있는 대상에게 전달할 수 있다. 이는 바운디드 컨텍스트 내부 또는 외부일 수도 있다.

이벤트 소싱 방식의 설계는 도메인 이벤트의 인과관계의 순서를 파악할 수 있지만, 같은 내의 분산돼 있는 다른 노드들에 도달할 것을 보장하는 것은 아니다. 이에 따른 적절한 인과관계를 파악하는 것은 이를 소비하는 바운디드 컨텍스트가 가져야 할 책임이다.

이벤트란 도메인에 주목할 만한 상태가 변경됐다는 것을 관계를 맺고 있는 모든 도메인에게 알리는 방법이다.

이를 인과관계라고도 표현하는데, 도메인 이벤트 그 자체가 인과관계를 나타내거나 시퀀스나 인과관계 식별자처럼 도메인 이벤트와 관계된 메타데이터 형태가 인과관계를 나타낼 수 도 있다.

인과관계가 확인되지 않았다면 이벤트 소비자들은 그 인과관계가 도달하기 전까지는 새롭게 도달할 이벤트를 기다린다. 어떤 경우에는 이후 메시지와 관계된 수행에 의해 특정 도메인 이벤트가 필요 없어진 경우도 있다. 이때 인과관계는 무시된다.

### 도메인 이벤트 발행 대상

일반적으로 이벤트 발행은 사용자 인터페이스에 의해 발현되는 사용자 기반 명령인 경우가 많다.

이외에도 애플리케이션에 등록된 배치나 스케쥴러에 의해 특정 시간대에 이벤트가 발행되기도 한다. 이 경우, 명령이 아닌 도메인 이벤트 시간으로 모델링을 설계해야 한다.

- 일반적으로 이벤트는 클라이언트에 의해 발행된다.
- 예외적으로 비즈니스 관점에서 중요한 시간에 의해 발행된다.
- 이벤트 발행 주체에 따라 모델링한다.

## 이벤트 소싱

이벤트 소싱이란 애그리게잇 인스턴스의 모든 상태 변화에 대한 기록으로, 발행됐던 모든 도메인 이벤트에 대한 이력이다.

- 애그리게잇 상태 전체를 저장하는 대신, 발행했던 각 도메인 이벤트 모두를 저장한다.
- 이를 지원하기 위해 하나의 애그리게잇 인스턴스에 발생했던 모든 도메인 이벤트를 발생한 순서대로 `이벤트 스트림`을 구성한다.
- 가장 처음 발생됐던 도메인 이벤트를 시작으로 마지막 도메인 이벤트까지 모든 변화를 순차적으로 기록한다.

이벤트 소싱을 사용하면 어떤 사유로 인해 메모리에서 삭제됐던 애그리게잇들을 이벤트 스트림을 통해 완전히 복원할 수 있다.

> 이때 이벤트 단위는 애그리게잇 도메인 상태 변화다. 하나의 비즈니스를 로직을 수행할 시점에 여러 도메인의 상태가 변경되는 시점 자체를 기록한다.

### 이벤트 스토어

이벤트 리파지토리는 모든 도메인 이벤트를 추가하는 순차적인 리파지토리 컬렉션 또는 테이블을 의미한다.

| Stream Id     | Stream Version | Event Type      | Event Content |
|---------------|----------------|-----------------|---------------|
| payment-seq-0 | 1              | PaymentCreated  | `{...}`       |
| license-seq-0 | 2              | LicenseAssigned | `{...}`       |
| server-seq-0  | 3              | ServerEnabled   | `{...}`       |
| ...           | N              |    |               |

- 이벤트 스토어는 오직 추가만 가능하다.
- 이런 특성으로 인해 리파지토리 메커니즘은 매우 빠르게 동작한다.
  - 매우 높은 처리량
  - 낮은 대기 시간
  - 높은 확장성

### 성능 고려하기

이벤트 소싱은 막대한 양의 데이터를 저장되고 관리하게 된다.

만일 주요 관심사 중 하나가 성능이라면, 캐싱과 스냅샷에 대해 알고 있고 있는 것이 좋다.

- 캐싱
  - 우선 가장 높은 성능을 요하는 애그리게잇을 메모리에 캐시한다.
  - 애그리게잇을 액터로  Reactive 액터 모델을 사용하는 것은 에그리게잇 상태를 캐싱으로 유지하는 쉬운 방법 중 하나다.
- 스냅샷
  - 이벤트 스트림으로부터 모든 도메인 이벤트를 다시 불러들이지 않고도 메모리에서 사라졌던 애그리게잇을 다시 메모리로 불러들이는 시간을 최적화시킬 수 있다.
  - 데이터베이스 내의 애그리게잇(객체, 액터 또는 레코드)이 증가하는 상태를 스냅샷을 통해 관리한다.

이벤트 소싱을 사용함으로써 얻을 수 있는 가장 큰 이점 중 하나는 핵심 도메인에서 계속 발생하는 모든 기록을 개별적인 발생 수준으로 저장한다는 점이다.

- 단기간으론 데이터의 분석에 용이하다.
- 장기간으론 개발자가 소스 코드를 디버깅하거나 이벤트 사용 추세를 조사할 때, 이벤트 스트림을 사용해볼 수도 있다.

## 요약

- 도메인 이벤트를 생성하고 이벤트 이름의 명명 규칙과 중요성
- 표준 도메인 이벤트 인터페이스를 정의하고 구현하는 것의 중요성
- 도메인 이벤트의 프로퍼티 정의 방법
- 도메인 이벤트 관리
- 이벤트 소싱과 애그리게잇의 상태를 표한 하기 위한 도메인 이벤트를 저장하고 사용하는 방법
