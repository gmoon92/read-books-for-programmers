# 5장 애그리게잇과 전술적 설계

이번 장에서는 애그리게잇에 초점을 맞춰 제품(Product), 백로그 아이템(BacklogItem), 릴리스(Release), 그리고 스프린트(Sprint)를 모델링하는 방법에 대해 다룬다.

## 엔터티란

엔터티란 독립적인 것이다.

각 엔터티는 같은 형태를 띠거나 다른 형태의 엔터티들과의 특성을 구별할 수 있는 고유한 식별성을 갖는다.

- 고유한 식별성를 갖는다.
- 상태가 변할 수 있거나 불변일 수 있다.

## 애그리게잇란

애그리게잇이란 1개 이상의 엔터티로 구성된다.

- 그중 한 엔터티는 애그리게잇 루트라고 부른다.
- 애그리게잇은 그 구성에 값 객체를 포함할 수 있다.
- 각 애그리게잇은 일관성 있는 트랜잭션 경계를 형성한다.
- 한 애그리게잇 내의 모든 구성 요소는 반드시 비즈니스 규칙을 따르면서 일광성 있게 처리된다는 것을 의미한다.
- 다만, 애그리게잇 내에 트랜잭션 이후 일관성이 지켜질 필요가 없는 다른 요소를 포함해서는 안 된다는 뜻은 아니다.
- 애그리게잇은 개념적으로 완전하게 모델링해야 하기 때문이다.
- 외부 경계는 각 객체들 전체에 대한 데이터 처리 원칙을 유지하면서 제어하는 트랜잭션으로 분뢰돼 있음을 나타낸다.

## 값 객체란

값 객체란 불변의 개념적 완전성을 모델링한다. 모델에서 값은 그야말로 값이다.

- 엔터티와 달리 고유한 식별성이 없다.
- 값 형태로 캡슐화된 속성을 비교함으로써 동일함이 결정된다.
- 값 객체가 어떤 것을 나타낸다기보다는 엔터티를 서술하고, 수량화하거나 측정하는 데 사용된다.

## 루트 엔터티

각 애그리게잇의 루트 엔티티는 애그리게잇 안의 다른 모든 요소를 소유한다.

- 루트 엔티티의 명칭은 애그리게잇의 개념적 명칭이다.
- 애그리게잇이 모델링하는 개념적 완전성을 적절하게 표현할 수 있는 명칭으로 루트 엔터티 명칭을 정의한다.

### 넓은 의미의 트랜잭션

애플리케이션에 대한 트랜잭션 사용은 어느 정도 구현에 관한 세부 사항이다.

- 도메인 모델에 일관성 있는 데이터베이스 트랜잭션을 제어하는 애플리케이션 서비스는 비교적 일반적인 기능이다.
- 하지만 액터 모델(Reactive)과 같은 다른 아키텍처 활용 사례에서는 각 애그리게잇을 액터로 구현하고, 트랜잭션은 데이터베이스에 대한 원자적(Atomic) 트랜잭션을 지원하지 않는 이벤트 소싱을 사용한다.
- 어느 쪽이든, **`트랜잭션`**이란 애그리게잇에 대한 변경을 독립시키고, 소프트웨어가 언제나 충실히 준수해야 하는 규칙인 비즈니스 불변성을 각 비즈니스 오퍼레이션에 맞게 일관성을 보장하는 방법이다.
- 원자적 데이터베이스 트랜잭션으로 처리하거나 다른 방법으로 처리하는 것과는 상관없이, 애그리게잇의 상태나 이벤트 소싱은 항상 안전하고 정확하게 트랜잭션으로 처리하고 관리해야 한다.

### 트랜잭션과 애그리게잇

- 트랜잭션 경계를 두는 이유는 비즈니스 때문이다.
- 애그리게잇이 유효한 상태인지, 아닌지를 결정하는 것은 비즈니스와 관련돼 있는 일이다.
- 애그리게잇이 완전하고 유효한 상태로 저장되지 않는다면, 수행된 비즈니스 오퍼레이션은 비즈니스 규칙에 어긋난 것으로 간주해야 한다.
- 2개의 애그리게잇이 정의돼 있다면, 둘 중 하나만 단일 트랜잭션으로 커밋돼야 한다.
- 하나의 트랜잭션에는 오직 1개의 애그리게잇만을 수정하고 커밋해야 한다.
- 이로인해 데이터의 일관성을 보장하며, 이를 애그리게잇을 트랜잭션의 일관성을 만드는 경계라고 부르는 이유다.

## 애그리게잇 경험 법칙

애그리게잇 설계의 네 가지 기본 규칙을 살펴보자.

1. 애그리게잇 경계 내에서 비즈니스 불변사항들을 보호하라.
2. 작은 애그리게잇을 설계하라.
3. 오직 ID를 통해 다른 애그리게잇을 참고하라.
4. 결과적 일관성을 사용해 다른 애그리게잇을 갱신하라.

### 규칙 1: 애그리게잇 경계 내의 비즈니스 불변사항을 보호하라.

결과적으로 규칙 1은 트랜잭션이 커밋될 때 비즈니스의 일관성이 지켜지는 것에 기반을 두고 애그리게잇 구성 요소를 결정해야 한다는 의미다.

데이터 일관성은 루트 엔티티로 부터 보장해야 한며 비즈니스 규칙에 따라 애그리게잇에 속한 구성요소가 일관적으로 데이터가 변경해야 됨을 의미한다.

### 규칙 2: 작은 애그리게잇을 설계하라.

이 규칙은 애그리게잇의 메모리 사용량과 트랜잭션 범위가 비교적 작아야 함을 강조한다.

기존 애그리게잇에 속한 구성 요소의 데이터가 많다면, 이러한 설계 방식은 매우 나쁜 선택이다. 몇몇의 구성요소를 새로운 애그리게잇로 구성하여 더 작은 메모리를 차지하게 된다면, 다양한 성능적인 이점을 얻을 수 있다.

- 빠른 로드
- 메모리 이점
- 가비지 컬렉션 이점
- 성공적인 트랜잭션 수행
- 유지 보수
- 테스트 이점

애그리게잇를 설계할 때 깊이 새겨둬야 할 또 다른 사항은 단일 책임의 원칙(SRP, Single Responsibility Principle)이다.

### 규칙 3: 오직 식별자로만 다른 애그리게잇을 참고하라

큰 애그리게잇을 작은 애그리게잇으로 분리했다면, 애그리게잇간의 참조는 오직 식별자로만 참고한다.

이것은 애그리게잇을 작게 유지하고, 동일한 트랜잭션 내에 여러 애그리게잇을 수정하려는 접근을 방지해준다.

이 규칙은 더 적은 메모리 요구와 리파지토리로부터 빠른 로딩을 통해 애그리게잇 설계를 작고 효율적으로 유지할 수 있게 해준다. 또한 동일한 트랜잭션 내에 다른 애그리게잇을 수정하지 않는 규칙이 잘 지켜지도록 해준다.

오직 애그리게잇의 식별자로 통해서만 접근이 가능하고, 그 외의 방법으로 다른 애그리게잇 내의 객체 레퍼런스를 얻어낼 수 있는 방법은 없다.

식별자만을 통해 레퍼런스를 얻는 규칙은 애그리게잇을 관계형 데이터베이스, 문서 데이터베이스, 키/밸류 리파지토리 그리고 데이터 그리드/패브릭(grids/fabrics)과 같은 다른 형태의 저장 메커니즘으로도 쉽게
저장할 수 있다는 것이다.

### 규칙 4: 결과적 일관성을 사용해 다른 애그리게잇을 갱신하라.

분리된 애그리게잇은 식별자를 통해 다른 애그리게잇을 참조한다.

다른 참조되는 애그리게잇의 데이터 일관성을 보장하기 위해선 도메인 이벤트를 활용한다.

- 애그리게잇의 트랜잭션의 일부로 도메인 이벤트를 발행시킨다. 다른 참조되는 애그리게잇의 상태는 도메인 인벤트로 부터 유지된다.
- 도메인 이벤트는 애그리게잇에 의해 발행된다. 이에 관심 있는 바운디드 컨텍스트는 이를 전달받는다.
- 관심 있는 바운디드 컨텍스트는 발행한 컨텍스트일 수도 잇고 다른 바운디드 컨텍스트일 수도 있다.

### 결과적 일관성이 두렵게 느껴진다면

결과적 일관성을 사용함에 있어 엄청나게 힘든 점은 없다.

- 그럼에도 불구하고, 실제 경험해보기 전까지는 결과적 일관성 사용에 대한 걱정이 있을 수도 있다.
- 그렇다고 해도 비즈니스에 의해 정의된 트랜잭션 경계에 따라 모델을 애그리게잇으로 분리시켜야 한다.
- 2개 이상의 애그리게잇을 단일한 데이터베이스 트랜잭션으로 묶어 처리하고 싶어 할 수도 있다.
- 다른 모두를 위해 일관성 있게 사용할 필요가 있다. 이는 초기 단계부터 너무 거대한 처리를 만들지 않도록 해주는 기법이다.
- 이것이 애그리게잇을 사용하는 근본적인 이유는 아니지만, 결과적으로 트랜잭션의 실패 경험을 줄여줄 수는 있을 것이다.

## 애그리게잇 모델링

도메인 모델 관련, 애그리게잇 구현에 대한 작업을 할 때. 몇 가지 주의 사항이 있다.

빈약한 도메인 모델(Anemic Domain Model)은 객체지향 도메인 모델을 사용하면서. 모든 애그리게잇이 비즈니스 행위가 아닌 읽고(getters) 쓰는(setters) 공개 접근자만 갖는다. 이는 모델링을
하면서 비즈니스보다는 기술적인 부분에 초점을 맞췄을 때 발생하는 경향이 있다.

- 도메인 모델이 주는 해택을 받지 못한다.
- 모든 오버헤드를 떠안아버리는 상황을 만든다.

비즈니스 로직이 도메인 모델을 넘어 애플리케이션 서비스까지 새어 나가지 않도록 주의해야 한다.

- 비즈니스 로직을 도우미(helper)나 유틸리티(utility) 클래스에 위임하는 것을 피해야 한다.
- 서비스 유틸리티는 항상 정체성에 혼란을 주고, 요구사항을 올바르게 유지시키지도 못한다.
- 비즈니스 로직을 도메인 모델 안에 정의하지 못한다면, 빈약한 도메인 모델이 만들어낸 벅드ㅡㄹ 때문에 고생할 수밖에 없다.

### 함수형 프로그래밍의 경우는?

함수형 프로그래밍에선 규칙이 상당히 많이 바뀐다. 빈약한 도메인 모델이 객체지향 프로그래밍에서는 나쁜 생각인 반면, 함수형 프로그래밍에선 다소 일반적이다.

함수형 프로그래밍은 데이터와 행위의 분리를 장려하기 때문인데, 불변하는 데이터 구조나 레코드 유형으로 데이터를 설계하고, 이렇게 설계된 데이터를 제어하는 순수한 함수로 행위를 구현하는 방식이다. 함수가 인자로 받은
데이터를 수정하는 대신, 함수가 새로운 값을 반환한다. 이 새로운 값은 애그리게잇의 상태 변환을 나타내주는 도메인 이벤트 또는 집합의 새로운 상태가 된다.

빈약한 도메인 모델을 개선 순서는 다음과 같다.

1. 가장 먼저 해야 할 것은 애그리게잇 루트 엔터티 클래스를 생성하는 것이다.
    - 모든 에그리게잇 루트 엔터티는 전체 시스템에서 고유한 식별성을 가져야 한다.
2. 값 객체의 사용
    - 변하지 않는 값은 값 객체로 모델링한다.
3. 본질적 송석을 위해 읽기 접근자(getters)와 같은 간단한 행위를 추가해도 된다.
4. 내부 상태를 변경시키는 행위와 관련된 메서드들은 함부로 외부에 공개해선 안된다.

## 추상화를 조심스럽게 선택하라

효과적인 소프트웨어 모델은 항상 일을 하는 비즈니스의 방식을 고려한 일련의 추상화에 기반을 두고 있다.

만일 보편언어와 관련된 가이드를 따른다면 적절한 추상화를 설정할 수 있다. 하지만 가끔은 잘못된 문제를 푸는 것에 지나치게 몰두한 나머지, 소프트웨어 개발자가 지나칠 정도로 추상화를 적용하기도 한다.

개발자가 스크럼의 보편언어를 모델링하는 것에 그다지 관심을 기울이지 않은 채, 현재와 미래의 모든 스크럼 관련 개념을 모델링하는 것에 더 많은 관심을 갖고 있는 경우엔 기존 보편언어의 정의를 퇴색하게 만든다.

- 소프트웨어 모델의 언어가 도메인 전문가의 멘탈 모델과 일치하지 않는다.
- 추상화 수준이 너무 높아서 각 개별적인 형태의 세부 사항을 모델링하기 시작하면 어려운 상황에 빠질 것이다.
- 각각의 클래스마다 특수한 경우를 정의할 것이고, 명백한 문제들에 대한 일반적인 접근을 통해 복잡한 클래스 계층 구조를 만든다.
- 우선적으로 중요하지 않은 문제를 해결하려다가 필요한 것보다 훨씬 많은 코드를 생상한다.
- 잘못된 추상화 수준은 심지어 사용자 인터페이스까지 영향을 미쳐 사용자에게 혼란을 주는 경우도 종종 발생한다.
- 이로 인해 상당한 시간과 비용을 낭비한다.
- 프로젝트 초반에 미래의 모든 요구를 생각하고 반영할 수는 없다. 새로운 스크럼 개념들은 앞으로도 계속 추가될 것이다. 기존 몬델은 그 요구사항을 예견하는 데 실패할 수밖에 없기 때문이다.

이러한 부적절한 추상화 수준은 기술적인 측면으로 구현을 생각하는 상황에서 자주 등장한다.

높은 수준의 추상화 구현이라는 덫에 현혹되지 말자. 팀이 정의한 도메인 전문가의 멘탈 모델에 따라 보편언어를 모델링해야 한다.

## 올바른 크기의 애그리게잇

비즈니스 불변사항을 보호할 일관성 경계는 여전히 유지하면서도, 애그리게잇의 경계를 결정하고, 큰 클러스터를 설계하는 것을 방지할 수 있을지 궁금할 것이다.

만일 이미 큰 클러스터의 애그리게잇을 만들었다면, 좀 더 작은 것들로 리팩토링하는 데 이 방법을 사용할 수도 있다. 하지만 이와는 다른 관점에서 시작해보자.

일관성 경계 목표에 도달하는 데 도움을 줄 아래 설계 단계들을 살펴보자.

1. 먼저 애그리게잇 설계의 두 번째 규칙인 "작은 애그리게잇을 설계하라"에 집중하자.
    - 애그리게잇 루트로 제공될 오직 1개의 엔터티만을 갖는 애그리게잇을 생성한다. 우선 2개의 엔터티를 두는 것은 생각하지 말자.
    - 각 엔터티들은 단일의 루트 엔터티와 관련이 가장 깊다고 생각되는 필드/속성/프로퍼티로 채운다.
2. 애그리게잇 설계의 첫 번째 규칙인 "애그리게잇 경계 내의 비즈니스 불변사항을 보호하라"로 관심을 돌리자.
    - 단일 엔터티 애그리게잇을 저장할 때 모든 필드/속성이 반드시 최신의 정보를 포함한 상태여야 한다.
    - 하지만 지금은 애그리게잇을 한 번에 하나씩 살펴봐야 한다.
    - 이미 정의한 다른 애그리게잇들 중 애그리게잇이 변경될 때 함께 갱신되야 하는 것이 있는지 도메인 전문가와 함께 확인한다.
    - 애그리게잇의 행위에 관련된 모든 갱신에 걸리는 시간을 파악할 수 있는 관련된 각 애그리게잇의 목록과 일관성 규칙을 만든다.
    - 애그리게잇 루트 엔터티를 앞단에, 그외 다른 애그리게잇을 그 아래에 위치시킨다.
3. 반응에 맞춘 갱신이 일어나는 시간은 얼마나 걸릴지 도메인 전문가에게 확인한다.
    - 즉시 또는 N초/분/시간/일과 같은 두 가지 유형의 명세로 정의한다.
    - 올바른 비즈니스 임계치를 찾는 한 가지 가능한 방법은 받아들여질 수 없는 과장된 소요 시간을 먼저 제시하는 것이다.
4. 각각의 애그리게잇들이 즉시 처리돼야 할 경우, 동일한 애그리게잇 경계 안에 그 2개의 엔터티를 구성하는 것을 긍정적으로 검토해야 한다.
5. 각각의 애그리게잇들이 주어진 시간에 따라 각각 반응하는 경우, 애그리게잇 설계의 네 번째 규칙인 "결과적 일관성을 사용해 다른 애그리게잇을 갱신하라"를 사용해서 갱신한다.

모든 애그리게잇이 함께 즉각적인 갱신에 들어가야 한다고 비즈니스측에서 일방적으로 주장하지는 않는지 주의를 기울여야 한다.

특히 설계 회의에 참여하는 많은 사람들이 데이터베이스 설계와 데이터 모델링에 영향을 받을 때 특히 강하게 이런 경향을 보일 수 있다. 그 이해관계자들은 트랜잭션 위주의 관점을 가질 것이다. 하지만 실제로 비즈니스가
모든 상황에 즉각적인 일관성을 요구할 가능성은 매우 낮다.

- 현재의 큰 클러스터 애그리게잇을 구성하는 여러 애그리게잇들에 걸친, 다수의 사용자들에 의해 동시에 발생하는 갱신들로 인해 어떻게 트랜잭션이 실패하게 될지 입증하는 데 시간을 보내는 상ㅎ황이 발생할 수도 있다.
- 큰 클러스터 설계로 인해 얼마나 많은 메모리 오버헤드가 발생하는지에 대해 이야기를 해야 할 수도 있다.
- 분명히 이런 문제들은 우선적으로 피하려고 노력해야 하는 것들이다.

이런 활동은 결과적 일관성이 기술 주도가 아닌, 비즈니스 주도라는 것을 보여준다. 물론, 다수의 애그리게잇 사이에 갱신을 위한 기술적인 방안도 찾아야 한다.

그렇지만 다양한 엔터티 간에 발생하는 갱신의 수용 가능한 소요 시간을 결정할 수 있는 것은 오직 비즈니스다. 이는 즉시 또는 적절한 트랜잭션으로 처리도애ㅑ 하는 것들은 동일한 애그리게잇으로 관리해야한다는 의미다.
또한 결과적인 일관성이 필요한 경우에는 메시징과 같은 도메인 이벤트를 통해 관리해야 한다는 의미다.

## 테스트 가능한 단위

단위 테스트를 위해 애그리게잇을 철저하게 캡슐화되도록 설계한다.

- 복잡한 애그리게잇은 테스트하기 어렵다.
- 단위 테스트를 만드는 일은 인수 테스트에 관한 시나리오 명세 만드는 과정을 따라 할 것이다.
- 여기서 고려해야 하는 것은 애그리게잇이 수행하길 기대하는 대로 정확하게 수행되는지 테스트하는 것이다.
