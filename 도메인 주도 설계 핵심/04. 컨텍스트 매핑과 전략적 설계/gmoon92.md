# 4장 컨텍스트 매핑과 전략적 설계

컨텍스트 매핑이란 애자일 프로젝트 관리 핵심 도메인을 다른 바운디드 컨텍스트와 통합하는 과정을 의미한다.

- DDD 프로젝트에는 핵심 도메인과 여러 개의 바운디드 컨텍스트가 존재한다.
- 핵심 도메인으로 정의한 애자일 프로젝트 관리 컨텍스트에 맞지 않는 다른 개념들은 전부 다른 바운디드 컨텍스트 중 하나로 옮기는 과정을 뜻한다.

## 컨텍스트 매핑

점선으로 된 상자는 컨텍스트 매핑의 일부가 아니라 선을 지칭하는 표시일 뿐이다.

- 2개의 바운디드 컨텍스트 사이의 이 선은 어떻게든 매핑돼 있다는 것을 의미한다. 두 바운디드 컨텍스트 사이에는 통합뿐만 아니라 팀 간의 다양한 관계도 존재할 수 있다.
- 다른 바운디드 컨텍스트는 각각의 보편언어가 정의되어 있다는걸 감안하면, 두 언어 사이의 통역을 나타내기도 한다.

보편언어를 다른 여러 개의 언어로 번역하거나 또 다른 방법으로 다른 보편언어를 처리한다 해도 각각의 장단점들이 존재할 수 밖에 없다.

컨텍스트 매핑을 살펴볼 때. 2개의 바운디드 컨텍스트 사이에 놓여진 선이 어떤 종류의 팀들 사이에 존재하는 관계와 통합인지에 주목해야 한다.

## 매핑의 종류

컨텍스트 매핑 선으로 어떤 관계와 통합을 표현할 수 있을까?

### 파트너십

두 팀 사이에 파트너십 관계가 존재할 수 있다.

각 팀은 하나의 바운디드 컨텍스트를 책임진다. 두 팀은 일련의 목표에 대한 의존성에 맞추기 위해 파트너십을 구성한다. 두 팀이 함께 성공하거나 다 같이 실패한다는 의미다.

- 장시간 파트너십을 유지하는 것은 매우 어려운 일이며, 파트너십에 참여하는 많은 팀들은 관계의 기한을 제한하고 싶어 할 수도 있다. 
- 파트너십이 상호간 이점을 제공한다면 관계를 지속시키고, 서로의 의존성이 줄어들어 이점이 사라지는 상황이라면 다른 관계로 매핑을 설정해야 한다.

### 공유 커널

두 바운디드 컨텍스트의 교차 지점으로 표시한 공유 커널(Shared Kernel)은 2개 이상 팀 사이에 작지만 공통인 모델을 공유하는 관계다.

각 팀은 공유하는 모델 요소에 대해 서로 협의해야 한다. 공유하는 모델의 코드, 빌드 관리는 한 팀에서 맡아서 수행한다.

### 고객-공급자

고객-공급자는 2개의 바운디드 컨텍스트와 각 팀들의 관계를 나타낸다.

- 공급자는 상류(U, Upstream)
- 고객은 하류(D, Downstream)

공급자는 고객이 원하는 것을 제공해야 하기 때문에, 관계를 주도한다.

다양한 기대를 충족시키기 위해 공급자와 함께 계획하는 것은 고객의 역할이다. 고객이 언제 무엇을 받게 될지는 결국 공급자가 결정한다.

### 준수자

준수자(Conformist) 관계는 상류와 하류 팀이 있고, 상류 팀이 하류 팀의 특정 요구에 지원할 동기가 없는 경우에 나타난다.

하류 팀이 자기들의 특정 요구에 맞춰 상류 모델의 보편언어를 계속 변환시키는 것은 어렵다. 따라서 현재의 상류팀 모델을 그대로 따르는 구조다.

이미 상류 모델이 확실하게 자리잡은 경우 이런 준수자 모델은 종종 등장한다. 

- AWS 시스템과 통합
- 외부 결제 시스템 통합

### 반부패 계층

반부패 계층(Anti-corruption Layer)은 가장 방어적인 컨텍스트 매핑 관계다.

하류 팀이 그들의 보편언어 모델과 상류 팀의 보편언어 모델 사이에 번역 계층을 만드는 것이다.

이 계층은 상류 모델로부터 하류 모델을 독립시키고 둘 사이를 번역한다.

### 공개 호스트 서비스

공개 호스트 서비스(OHS, Open Host Service)는 일련의 서비스처럼 여러분의 바운디드 컨텍스트에 대한 접근을 제공하는 프로토콜이나 인터페이스를 정의한다.

그 프로토콜은 해당 바운디드 컨텍스트와 통합하고자 하는 모두가 용이하게 사용할 수 있도록 "공개"돼 있다. 애플리케이션 프로그래밍 인터페이스(API)로 제공하는 서비스는 문서화가 잘돼 있고 사용하기 좋다.

### 공표된 언어

공표된 언어(PL, Published Language)는 이를 사용하는 바운디드 컨텍스트의 규모에 관계없이, 모두 간단한 사용과 번역을 가능하게 하는 잘 문서화된 정보 교환 언어다.

공표된 언어로 XML 스키마, JSON 스키마, 프로토버프(Protobuf)나 아브로(Avro)처럼 좀 더 최적화된 작성 형식으로 정의할 수 있다.

일반적으로 공개 호스트 서비스(OHS)는 서드파티에게 컨텍스트 매핑을 할 수 있는 공표된 언어를 제공한다. 이 결합은 매우 편리하게 두 보편언어 사이에 번역을 제공한다.

### 각자의 길

각자의 길(Separate Ways)은 1개 이상의 바운디드 컨텍스트를 통합으로, 다양한 보편언어를 사용하는 것이 유의미한 결과를 제공하지 못하는 상황을 말한다.

### 큰 진흙 덩어리

큰 진흙 덩어리를 만드는 일은 피해야 한다.

부적절한 연결과 의존 관계로 문제를 확산시키는 애그리게잇이 증가한다.

시스템 일부의 문제가 해결돼도 또 다른 문제를 계속 야기시킬 수 있기 때문엥 전반적 지식과 모든 언어를 한 번에 다룰 수 있는 영웅 같은 사람이 있어야 시스템을 완전한 붕괴로부터 지킬 수 있다.

DDD 기술을 사용해서 큰 진흙 덩어리가 만들어지는 것을 피한다 해도 여전히 외부의 큰 진흙 덩어리들과 통합해야만 하는 상황이 있을 수 있다.

1개 이상의 큰 진흙 덩어리와 반드시 통합해야 한다면, 각 레거시 시스템에 대응한 반부패 계층을 만들어서 형편 없는 결과로부터 모델을 보호해야 한다.

## 컨텍스트 매핑 활용하기

바운디드 컨텍스트와 통합할 때 어떤 종류의 인터페이스를 제공받을 수 있는지 선택해야 한다.

이것은 해당 바운디드 컨텍스트를 소유한 팀에 달려 있다.

- SOAP (RPC)
- RESTful API (Resource)
- Messaging (pub/sub)

상황이 나쁜 경우 데이터베이스나 파일 시스템의 통합을 강요받을 수도 있다. 데이터 베이스 통합은 진짜 피해야 한다. 그래도 통합을 강요받는 상황이라면 반부패 계층을 통해 독립된 시스템 구성으로 모델을 보호해야 한다.

좀 더 신뢰할 수 있는 세 가지 통합 형태에 대해 알아보자. 비교적 덜 견고한 방법에서 가장 견고한 통합 방법 순으로 설명한다.

### SOAP을 이용한 RPC

원격 프로시저 호출(Remote Procedure Calls)인 RPC는 다양한 방법으로 동작한다. RPC의 잘 알려진 사용법 중 하나는 SOAP을 이용한 방법이다.

SOAP을 이용한 RPC는 다른 시스템이 서비스를 사용할 때 마치 단순히 로컬 프로시저나 메서드를 호출하는 것처럼 사용한다는 개념이다.

SOAP RPC 방식은 다음을 보장해야 한다.

- 네트워크상에서의 요청
- 원격 시스템에 요청 전달
- 성공적 수행
- 네트워크를 통한 결과 반환

하지만 첫 시스템 통합 수행 시점에 예기치 못한 네트워크 장애나 작게는 지연의 가능성을 동반할 수 있다.

게다가 RPC 방식의 주된 문제는 견고함이 떨어질 수 있다는 점이다. RPC 방식은 클라이언트 바운디드 컨텍스트와 서비스를 제공하는 바운디드 컨텍스트 사이의 강한 결합을 암시한다.

네트워크나 SOAP API를 호스팅하는 시스템에 문제가 생기면, 간단한 프로시저 호출은 에러 결과만 받은 채 완전히 실패할 것이다. 사용하기 쉬워 보인다고 해서 속으면 안된다.

RPC가 제대로 동작하기만 한다면, 통합하기에 매우 좋은 방법일 수 있다.

```text
   S1          [SOAP/XML]        C1
[OHS/PL]    <--------------->   [ACL]
```

- S1: Service BOUNDED CONTEXT
- C1: Client BOUNDED CONTEXT

만약 RPC에 의해 서비스 바운디드 컨텍스트 설계에 영향을 줄 수 있다면, 앞단에 공표된 언어(PL)과 공개 호스트 서비스(OHS)를 제공하는 잘 설계된 API를 구성하고 싶어 할 것이다.

어쨌든, 외부의 잘 설계된 API의 존재 유무와 상관 없이, 원치 않는 외부의 영향으로부터 클라이언트 바운디드 컨텍스트를 분리할 필요가 있다면 반부패 계층(ACL)을 정의하자. 

### 레스트풀 HTTP

레스트풀 HTTP를 사용한 통합은 바운디드 컨텍스트 간에 교환되는 리소스뿐만 아니라, POST, GET, PUT, DELETE 이렇게 네 가지 주요 오퍼레이션들이 관여된다.

```text
   S1         [RESTful HTTP]     C1
[OHS/PL]    <--------------->   [ACL]
```

- S1: Service BOUNDED CONTEXT
- C1: Client BOUNDED CONTEXT

분산 컴퓨팅에 적합한 API들을 정의하는 데 도움을 주기 때문에, 컨텍스트 통합에 REST 방식을 많이 사용한다. 다만 REST를 적용하기 전에 반드시 유념해야 할 개념들을 살펴보는 데 좋은 출발점이다.

서비스 바운디드 컨텍스트는 REST 인터페이스를 제공한다. 공개 호스트 서비스와 공표된 언어를 제공해야 한다. 공표된 언어로 리소스를 정의하고 REST URI로 구성하면 온전한 공개 호스트 서비스를 구성할 수 있다.

레스트풀 HTTP는 네트워크나 서비스 제공자의 장애 또는 예기치 않은 지연 등 RPC에서의 실패 원인과 동일한 사유로 실패할 수도 있다.

하지만 REST HTTP 방식은 인터넷의 전제에 기반을 두고 있고, 웹이 보여준 신뢰성, 확장성 그리고 지금까지의 성공에 대해 누가 흠 잡을 수 있는 상황이 아니다.

REST를 사용할 때 저지르는 흔한 실수는 리소스를 설계할 때, 도메인 모델 안에 직접적으로 애그리게잇을 반영하는 것이다.

- 클라이언트에게 준수자 관계를 강요.
- 모델 변화가 리소스의 형태에 영향을 준다.
- 중요한 것은 클라이언트가 원하는 것은 모델의 지금 현재 구성이 아니라 리소스의 설계를 활용하는 것이다.

### 메시징

메시징을 활용한 통합은 가장 견고한 형태 중 하나다.

통합에 비동기 메시징을 사용하면, 바운디드 컨텍스트 또는 다른 바운디드 컨텍스트가 발행하는 도메인 이벤트를 구독하는 클라이언트 바운디드 컨텍스트가 많은 것을 할 수 있게 해준다.

이는 RPC나 REST HTTP 방식과 달리 분절된 형태와의 일시적인 결합을 대부분 제거할 수 있기 때문이다.

즉각적인 결과가 필수적이지 않을 때는 메시징을 이용해 좀 더 견고한 시스템을 구축하는 것도 좋은 선택이다.

### REST를 사용해 비동기 하기

점차 증가하는 리소스들에 대해 REST 기반으로 폴링(polling)하는 방식으로 비동기 메시징을 구현해 처리할 수도 있다.

클라이언트는 백그라운드 프로세싱을 사용함으로써 계속해서 증가하는 일련의 도메인 이벤트를 제공하는 아톰 피드(Atom feed) 리소스를 지속적으로 폴링할 수 있다.

서비스에서 계속 이벤트가 발생하는 상황이라면 서비스와 클라이언트 사이에 비동기 오퍼레이션을 유지하는 매우 안전한 방식이다. 만약, 서비스가 어떤 사유로 인해 이용이 불가능하게 되면 클라이언트는 특정한 주기로 재시도하거나 리소스를 다시 이용할 수 있는 사황이 될 때 재시도 할 수 있다.

### 열차 충돌을 막아라

클라이언트 바운디드 컨텍스트(C1)를 서비스 바운디드 컨텍스트(S1)와 통합할 때 요청 처리 결과를 바로 사용하는 동기화 방식이 아닌, C1에서 S1으로의 요청 처리 결과를 바로 사용하는 동기화 방식이 아닌, C1에서 S1으로의 요청을 비동기적으로 처리할 필요가 있다.

동기화 방식으로 처리할 경우, 공통 자원(임계 영역)에 대한 대기열이 지연되어 서비스 바운디드 컨텍스트에 대한 응답 지연 현상이 발생할 수 있다. 비동기 메시징 방식을 통해 클라이언트오아 서비스 간의 응답 지연을 발생할 수 있는 열차 사고 발생을 막을 수 있다.

일반적으로 바운디드 컨텍스트 내의 애그리게잇은 도메인 이벤트를 만들 때 관심 있는 다른 컨텍스트들은 발생된 이벤트를 사용한다.

구독 바운디드 컨텍스트가 도메인 이벤트를 받으면, 이벤트의 형태와 값을 토대로 동작을 수행한다.  이때 소비하는 바운디드 컨텍스트 안에 새로운 애그리게잇을 생성하거나 기존 애그리게잇을 수정해야 할 때가 있다.

### 도메인 이벤트 소비자는 준수자인가?

바운디드 컨텍스트 통합 과정에서 다른 바운디드 컨텍스트가 도메인 이벤트를 소비할 수 있게 해주고, 이를 소비하는 바운디드 컨텍스트에게 준수자 관계를 강요하지 않아야 한다.

소비자들은 이벤트 발행자의 인벤트 형태(ex. Class)를 사용하면 안 된다. 

오직 이벤트의 스키마(공표된 언어)에만 의존해야 한다. 만약, 이벤트가 JSON 또는 좀 더 간결한 오브젝트 포맷으로 발행되면, 소비자는 그들을 파싱해서 데이터 속성들을 얻은 후 이벤트를 처리해야 한다.

### 메시징 메커니즘

통합에 메시징을 사용하는 모든 경우, 전체 솔루션의 품질은 사용한 메시징 메커니즘의 품질에 크게 좌우된다. 

적어도 한 번의 전달(At-least-once delivery)을 통해 모든 메시지의 수신을 보장해야 한다. 이는 구독 바운디드 컨텍스트가 멱등 수신자(Idempotent Receiver)로 구현돼야 함을 의미한다.

적어도 한 번의 전달(Reactive)은 메시징 메커니즘이 특정 메시지를 주기적으로 재전달하는 메시징 패턴이다. 이것은 메시지 손실, 느린 반응, 수신자 장애, 수신자가 수신 사실을 알리는 데 실패하는 상황에서도 적용된다.

이 메시징 메커니즘 설계로 인해, 발송자가 단 한 번 메시지를 전달했더라도 메시지는 여러 번 전달될 수 있다. 수신자가 이런 상황을 바탕으로 설계했더라도 문제될 것은 없다.

### 멱등 수신자

멱등 수신자는 여러번 메시지를 전달 받는 상황을 고려하여, 메시지가 제대로 처리할 수 있도록 설계해야 한다. 멱등 수신자는 반복된 메시지를 수신하더라도 동일한 결과를 반환해야 한다.

- 중복 제거
- 반복 메시지 무시
- 이전에 전달된 메시지의 결과와 정확히 동일한 결과 응답

메시징 메커니즘이 항상 비동기 요청-응답 통신을 사용하기 때문에 어느 정도의 지연은 일반적이고 당연하다.

서비스가 종료되기 전에는 서비스에 대한 요청이 절대 막힐 일이 없기 때문에. 어느 정도의 지연 발생을 감내할 수만 있다면, 메시징으로 설계하는 것은 전체 솔루션을 처음부터 매우 견고하게 만들 수 있다는 것을 의미한다.

## 컨테스트 매핑 사례

다른 바운디드 컨텍스트에서 동일한 보편언어를 참조하기 위해 도메인 이벤트를 발생 시킨다.

이때 발행된 도메인 이벤트는 식별자를 담고 있고, 식별자를 통해 구독 바운디드 컨텍스트에 생성된 모든 컴포넌트는 발신 주체인 컨텍스트를 역추적하기 위해 식별자를 보유하고 있다. 필요하다면 식별자 이외의 정보들을 관리할 수도 있다. 

### 모두 담는 것과 다시 쿼리하는 것 사이의 장단점

때때로 모든 소비자를 만족시키기 위해 도메인 이벤트에 충분한 데이터를 모두 담아야 이점을 얻을 수 있을 때가 있다.

반면 도메인 이벤트를 가볍게 유지하고 소비자가 더 많은 데이터를 요청할 때 다시 가져오는 것이 더 이로울 때도 있다.

모두 담는 것을 선택하면 소비자들에게 큰 자율성을 허용할 수 있는데, 자율성이 핵심 요구사항이라면 이 방법을 선택하는 것이 좋다.

한편, 모든 소비자가 도메인 이벤트에 요구할 모든 데이터를 예측하는 것이 너무 어렵고, 모든 것을 제공하려면 너무 많은 것을 담아야 할 수도 있다.
