# 5. 프로듀서의 내부 동작 원리와 구현

- [파티셔너](#51-파티셔너)
- [프로듀서의 배치](#52-프로듀서의-배치)
- [중복 없는 전송](#53-중복-없는-전송)
- [정확히 한 번 전송](#54-정확히-한-번-전송)

## 5.1. 파티셔너

파티셔너는 프로듀서가 토픽으로 전송한 메시지를 토픽의 어느 파티션으로 메시지를 보내야할지 결정하는 역할을 한다.

> 토픽은 병렬 처리가 가능하도록 토픽 내부에 파티션을 나누고 최소 하나 또는 둘 이상의 파티션으로 구성된다. 프로듀서가 카프카로 전송한 메시지는 해당 토픽 내 각 파티션의 **로그 세그먼트**에 저장된다.

### 5.1.1. 파티션 분배 전략

- 해시: 메시지(레코드)의 키를 해시(hash) 처리해 파티션을 구하는 방식
- 라운드 로빈:
- 스티키 파티셔닝 전략:

### 5.1.1.1. 해시 전략

**메시지(레코드)에 키가 존재할 경우**, 프로듀서가 파티션을 결정하는 알고리즘은 기본적으로 해시 기반 방식으로 동작된다.

해시 기반은 메시지(레코드)의 키를 해시(hash) 처리해 파티션을 구하는 방식으로 메시지의 키 값이 동일하다면, 해당 메시지들은 모두 같은 파티션으로 전송된다.

그러나 파티션 수가 변경되면 기존의 키-파티션 매핑도 변경될 수 있다.

![kafka-partitioner-hash.png](../imges/05/kafka-partitioner-hash.png)

카프카는 클라이언트의 처리량을 높이기 위해 토픽의 파티션을 확장할 수 있는 기능을 제공한다. 이때 파티션 수가 변경됨과 동시에, 메시지의 키와 매핑된 해시 테이블도 변경된다.

즉, 프로듀서가 동일한 키를 가진 메시지를 전송하더라도, 파티션 개수가 변경되면 해당 키가 새로운 파티션에 매핑될 가능성이 있다. 이로 인해 키를 기준으로 한 메시지의 순서가 보장되지 않을 수 있으므로, 파티션 수
변경 시 주의가 필요하다.

### 5.1.1.2. 라운드 로빈 전략

**메시지(레코드)에 키가 없는 경우**, 프로듀서는 라운드 로빈 알고리즘을 사용해 메시지를 목적지 토픽의 파티션들로 균등하게 분배한다.

> 프로듀서가 메시지를 전송할 때 레코드의 키는 필수 항목이 아니므로, 관리자는 별도의 키 값을 지정하지 않고 메시지를 전송할 수 있다.

파티셔너를 거친 후, 레코드들은 배치 처리를 위해 `프로듀서의 버퍼 메모리 영역`에 잠시 대기한 후 카프카로 전송된다.

![kafka-partitioner-round-robin.png](../imges/05/kafka-partitioner-round-robin.png)

1. 각 파티션별로 배치 전송을 위해 필요한 레코드 수는 3으로 설정됐다.
2. 프로듀서는 메시지 생성한다.
3. 생성된 메시지는 파티셔너로 전달한다.
4. 파티셔너는 `라운드 로빈 방식`으로 메시지를 파티션에 할당한다
    - `레코드1` -> `파티션0`
    - `레코드2` -> `파티션1`
    - `레코드3` -> `파티션2`
    - `레코드4` -> `파티션0`
    - 프로듀서 레코드가 파티셔너에 전송되면 위 레코드 할당 과정은 반복한다.
5. 메시지는 `프로듀서의 버퍼 메모리`에 대기하며, 최소 배치 크기가 모일 때까지 기다린 후 카프카로 전송된다.

라운드 로빈 전략은 메시지 분배를 균등하게 하여 `메시지의 분배 효율성`을 높이지만, 배치 처리가 지연될 경우 대기 시간이 길어져 성능에 영향을 미칠 수 있다.

### 5.1.1.3. 스티키 파티셔닝 전략

## 5.2. 프로듀서의 배치

## 5.3. 중복 없는 전송

## 5.4. 정확히 한 번 전송
