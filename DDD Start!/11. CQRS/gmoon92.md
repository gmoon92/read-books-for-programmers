# CQRS

- 명령 모델과 조회 모델
  - [단일 모델의 단점](#단일-모델의-단점)
  - [CQRS](#CQRS)
  - [웹과 CQRS](#웹과-CQRS)
- CQRS 장단점
  - [CQRS 장단점](#CQRS-장단점)

## 단일 모델의 단점

여러 애그리거트에서 데이터를 가져와야 할 경우 구현 방법을 고민해야 한다.

- ID를 활용한 간접 참조 방식을 사용하면 즉시 로딩(eager loading) 방식과 같은 JPA의 쿼리 관련 최적화 기능을 사용할 수 없다.
- 직접 참조 방식을 사용해도 글로벌 패치 전략을 상황에 맞게 설정해야 된다.
- 경우에 따라 DBMS가 제공하는 전용 기능을 이용해서 조회 쿼리를 작성해야 될 경우 JPA의 네이티브 쿼리를 사용해야 할 수도 있다.

이런 고민이 발생하는 이유는 시스템의 상태를 변경할 때와 조회할 때 단일 도메인 모델을 사용하기 때문이다.

객체지향으로 도메인 모델을 구현할 때 주로 사용하는 ORM 기법은 도메인의 상태 변경을 구현하는 데는 적합하지만, 여러 애그리거트에서 데이터를 가져와 조회하는 기능을 구현하기엔
적합하지 않다.

이런 구현 복잡도를 낮추는 간단한 방법이 있는데 그것은 바로 상태 변경을 위한 모델과 조회를 위한 모델을 분리하는 것이다.

## CQRS

시스템이 제공하는 기능은 크게 두 가지로 나누어 생각해 볼 수 있다.

- 상태 변경
- 상태 조회

도메인 모델 관점에서 상태 변경 기능은 주로 한 애그리거트의 상태를 변경한다.

반면에 조회 기능은 한 애그리거트의 데이터를 조회할 수도 있지만, 두 개 이상의 애그리거트에서 데이터를 조회할 수도 있다.

상태 변경하는 범위와 상태를 조회하는 범위가 정확하게 일치하지 않기 때문에 단일 모델로 두 종류의 기능을 구현하면 모델이 불필요하게 복잡해진다.

CQRS 는 단일 모델을 사용할 때 상태 변경과 조회에서 발생하는 복잡도를 해결한다.

![Start DDD!](/img/start-ddd/cqrs-pattern.png)

_출처 Start DDD!_

CQRS(Command Query Responsibility Segregation)은 상태를 변경하는 명령(Command)을 위한 모델과 상태를 제공하는 조회(Query)를 위한
모델을 분리하는 패턴이다.

CQRS는 복잡한 도메인에 적합하다.

- 도메인이 복잡할수록 명령 기능과 조회 기능이 다루는 데이터 범위에 차이가 발생한다.
- 조회 기능의 로딩 속도를 위해 모델 구현이 필요 이상으로 복잡해지는 문제가 발생한다.
- JPA 기반의 단일 도메인 모델에 사용하면 통계와 같은 여러 애그리거트의 데이터를 빠르게 조회하기 위해 JPA 와 관련된 다양한 성능 관련 기능을 모델에 적용해야 한다.
  - CQRS를 적용하면 통계를 위한 조회 모델을 별도로 만들기 때문에 조회 때문에 도메인 모델이 복잡해지는 것을 막을 수 있다.

CQRS는 각 모델에 맞는 구현 기술을 선택할 수 있다.

```text
명령 모델: controller -> application -> domain -> infra(JPA 리포지토리 구현) -> DB
조회 모델: DTO/DAO -> infra(MyBatis: DAO 구현) -> DB  
```

CQRS 패턴을 적용하기 위해 반드시 사용해야 할 기술이 따로 존재하는 것은 아니다.

- 명령 모델과 조회 모델을 서로 다른 기술을 이용해서 구현할 수 있다.
- 예를 들어 명령 모델은 JPA를 사용해서 구현하고, 조회 모델은 MyBatis를 사용해서 구현할 수 있다.
- 때론 같은 구현 기술을 사용해서 설계할 수 있다.
  - 명령 모델: JPA
  - 조회 모델: JPA, 동적 인스턴스 생성과 조회 전용 기능 구현의 @Subselect를 이용한 방법
- 명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 수 있다.
  - 명령 모델: 트랜잭션을 지원하는 RDBMS 사용
  - 조회 모델: 조회 성능이 좋은 메모리 기반 NoSQL 사용
  - 두 테이터 저장소 간의 데이터 동기화는 이벤트를 활용해서 처리한다.
  - 명령 모델에서 상태를 변경하면 조회 모델에 전달해서 변경 내역을 반영한다.
  - 서로 다른 데이터 저장소를 사용할 경우 데이터 동기화 시점에 따라 구현 방식이 달라진다.
    - 동기화 이벤트 방식
      - 글로벌 트랜잭션과 동기 이벤트를 사용해서 실시간 조회 모델 데이터 반영
      - 글로벌 트랜잭션을 사용하면 전반적인 성능(응답 속도와 처리량)이 떨어지는 단점이 존재한다.
    - 비동기화 이벤트 방식

## 웹과 CQRS

일반적인 웹 서비스 상태를 변경하는 요청보다 조회하는 요청이 많다.

조회 성능을 높이기 위해 다양한 기법을 사용한다.

- 쿼리 최적화
- 조회 데이터 캐시 적용
- 조회 전용 저장소 분리

조회 성능을 높이기 위해 다양한 기법을 사용하는 것은 결과적으로 CQRS를 적용하는 것과 같은 효과를 만든다.

메모리에 캐시하는 데이터는 DB에 보관된 데이터를 그대로 저장하기보다는 화면에 맞는 모양으로 변환한 데이터를 캐시할 때 성능에 더 유리하다.

대규모 트래픽이 발생하는 웹 서비스는알게 모르게 CQRS를 적용하게 된다. 단지, 명시적으로 명령 모델과 조회 모델을 구분하지 않을 뿐이다.

조회 속도를 높이기 위해 별도 처리를 하고 있다면 명시적으로 명령 모델과 조회 모델을 구분해야 한다. 

- 이는 조회 기능 때문에 명령 모델이 복잡해지는 것을 방지할 수 있다.
- 명령 모델에 관계없이 조회 기능에 특화된 구현 기법을 보다 쉽게 적용할 수 있다.

## CQRS 장단점

CQRS 장단점을 고려해서 CQRS 패턴을 도입할지 여부를 결정해야 한다.

도메인이 복잡하지 않은데 CQRS를 도입하면 두 모델을 유지하는 비용만 높아지고 얻을 수 있는 이점은 없다. 

반면에 트래픽이 높은 서비스인데 단일 모델을 고집하면 유지보수 비용이 오히려 높아질 수 있으므로 CQRS 도입을 고려해보자.

### CQRS 패턴의 장점

![Start DDD!](/img/start-ddd/cqrs1.png)

_출처 Start DDD!_

- 명령 모델을 구현할 때 도메인 자체에 집중할 수 있다.
  - 복잡한 도메인은 주로 상태 변경 로직이 복잡한데 명령 모델과 조회 모델을 구분하면 조회 성능을 위한 코드가 명령 모델에 없으므로 도메인 로직을 구현하는 데 집중할 수 있다.
  - 명령 모델에서 조회 관련 로직이 사라져 복잡도를 낮춰준다.
- 조회 성능을 향상시키는 데 유리하다는 점이다.
  - 조회 단위로 캐시 기술을 적용할 수 있고, 조회에 특화된 쿼리를 마음대로 사용할 수도 있다.
  - 캐시뿐만 아니라 조회 전용 저장소를 사용하면 조회 처리량을 대폭 늘릴 수 있다.
  - 조회 전용 모델을 사용하기 때문에 저회 성능을 높이기 위한 코드가 명령 모델에 영향을 주지 않는다.

### CQRS 패턴의 단점

- 구현해야 할 코드가 더 많다.
  - 단일 모델을 사용할 때 발생하는 복잡함 때문에 발생하는 구현 비용과 조회 전용 모델을 만들 때 발생하는 구현 비용을 따져봐야 한다.
  - 도메인이 복잡하거나 대규모 트래픽이 발생하는 서비스라면 조회 전용 모델을 만드는 것이 향후 유지보수에 유리할 수 있다.
  - 반면에 도메인이 단순하거나, 트래픽이 많지 않은 서비스라면 조회 전용 모델을 만들 이유가 없다.
- 더 많은 구현 기술이 필요하다.
  - 명령 모델과 조회 모델을 다른 구현 기술을 사용해서 구현하기도 하고 경우에 따라 조회 전용 저장소를 사용하기도 한다.
  - 데이터 동기화를 위해 메시징 시스템을 도입해야 할 수도 있다.
