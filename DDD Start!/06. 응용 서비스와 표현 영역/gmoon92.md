# 6장 응용 서비스와 표현 영역

- 응용 서비스 구현
  - [표현 영역과 응용 영역](#표현-영역과-응용-영역)
  - [응용 서비스의 역할](#응용-서비스의-역할)
    - [도메인 로직 넣지 않기](#도메인-로직-넣지-않기)
  - [응용 서비스의 구현](#응용-서비스의-구현)
    - [응용 서비스의 크기](#응용-서비스의-크기)
    - [응용 서비스의 인터페이스와 클래스](#응용-서비스의-인터페이스와-클래스)
    - [메서드 파라미터와 값 리턴](#메서드-파라미터와-값-리턴)
    - [표현 영역에 의존하지 않기](#표현-영역에-의존하지-않기)
    - [트랜잭션 처리](#트랜잭션-처리)
    - [도메인 이벤트 처리](#도메인-이벤트-처리)
- 표현 영역의 역할
  - [표현 영역](#표현-영역)
- 값 검증과 권한 검사
  - [값 검증](#값-검증)
  - [권한 검사](#권한-검사)
- [조회 전용 기능과 응용 서비스](#조회-전용-기능과-응용-서비스)

## 표현 영역과 응용 영역

- 표현 영역은 사용자의 요청을 해석한다.
  - 사용자가 어떤 기능을 실행하고 싶어 하는지 판별하고 그 기능을 제공하는 응용 서비스를 실행한다.
- 응용 영역은 사용자와 도메인을 연결해 주는 매개체다.
  - 사용자에게 기능을 제공하기 위한 역할을 한다.
  - 응용 서비스는 표현 영역에 의존하지 않는다.
    - 기능 실행에 필요한 입력값을 전달받고 결과만 리턴하면 된다.

## 응용 서비스의 역할

응용 서비스는 클라이언트가 요청한 기능을 실행한다.

- 클라이언트의 요청을 처리하기 위해 리포지터리로부터 도메인 객체를 구하고, 도메인 객체를 사용한다.
- 응용 서비스의 주요 역할은 도메인 객체를 사용해서 사용자의 요청을 처리하는 것이다.
- 표현 영역 입장에서 응용 서비스는 도메인 영역과 표현 영역을 연결해 주는 창구인 파사드(facade) 역할을 한다.
- 주로 도메인 객체 간의 흐름을 제어한다.
- 응용 서비스의 주된 역할은 다음과 같다.
  - 트랜잭션 처리
    - 도메인의 상태 변경을 트랜잭션으로 처리해야 한다.
  - 접근 제어
  - 이벤트 처리

```java
public class SomService {

    public Result doSomeFunc(SomeReq req) {
        // 1. 리포지터리에서 애그리거트를 구한다.
        SomeAgg agg = someAggRepository.findById(req.getId());

        // 2. 애그리거트의 도메인 기능을 실행한다.
        agg.doFunc(req.getValue());

        // 3. 결과를 리턴한다.
        return createSuccessResult(agg);
    }

    public Result doSomeCreation(CreateSomeReq req) {
        // 1. 데이터 중복 등 데이터가 유효한지 검사한다.
        checkValid(req);

        // 2. 애그리거트를 생성한다.
        SomeAgg newAgg = createSome(req);

        // 3. 리포지터리에 애그리거트를 저장한다.
        someAggRepository.save(newAgg);

        // 4. 결과를 리턴한다.
        return createSuccessResult(newAgg);
    }
}
```

### 도메인 로직 넣지 않기

응용 서비스는 도메인 로직을 구현하지 않는다. 도메인 로직은 도메인 영역에 위치해야 한다.

- 코드의 응집성을 높인다.
  - 도메인 로직이 응용 영역 곳곳에 흩날려져 도메인 로직을 파악하기 위해 여러 영역을 분석해야 한다.
- 중복 코드를 야기할 가능성이 높다.
  - 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다.

```java
public class ChangePasswordService {

    public void changePassword(String memberId, String oldPwd, String newPwd) {
        Member member = memberRepository.findById(memberId);

        // 서비스에 도메인 로직을 구현하지 않는다.
        // check valid password logic...
        // member.setPassword(newPwd);
        
        // 도메인 객체간의 실행 흐름 제어
        member.changePassword(oldPwd, newPwd);
    }

}
```

## 응용 서비스의 구현

응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 한다.

> 이는 디자인 패턴에서 파사드(facade)와 같은 역할을 한다.

### 응용 서비스의 크기

응용 서비스 구현은 서비스 크기를 고려해야 한다.

기본적으로 응용 서비스 구현 방식은 크게 두 가지다.

- [] 한 응용 서비스 클래스에 도메인의 모든 기능 구현
  - 특정 도메인과 관련된 기능을 구현한 코드가 하나의 서비스 클래스에 있도록 설계하는 방식
  - 도메인에 대한 모든 기능을 서비스에 구현하기 때문에 서비스 코드가 비대해진다.
  - 코드 크기가 커진다는 것은 연관성이 적은 코드가 한 클래스에 함께 위치할 가능성이 높아진다는 의미다.
  - 코드 중복을 제거할 수 있다.
- [X] 구분되는 기능별로 응용 서비스 클래스를 따로 구현
  - 코드 품질을 일정 수준으로 유지하는 데 도움이 된다.
  - 클래스 개수가 많이진다는 단점이 존재한다.
  - 각 클래스별로 필요한 의존 객체만 포함하므로 다른 기능을 구현한 코드에 영향을 받지 않는다.

### 응용 서비스의 인터페이스와 클래스

명확한 이유 없이 인터페이스 구성하는건 좋은 설계 방식이라 보기 어렵다.

서비스 클래스에 인터페이스가 필요한 경우는 다음과 같다.

- 구현 클래스가 여러 개인 경우
  - 구현 클래스가 여러 개인 경우는 매우 드물다.
- 구현 클래스가 다수 존재하거나 런타임에 구현 객체를 교체해야 할 경우
  - 구현 객체를 교체하는 경우는 매우 드물다.

이런 이유로 인터페이스와 클래스를 따로 구현하면 소스 파일만 많아지고 구현 클래스에 대한 간접 참조가 증가해서 전체 구조만 복잡해지는 문제가 발생한다.

예외적으로 TDD 로 개발한다면, 표현 영역을 우선 개발할 경우(ex. 컨트롤러 개발) 인터페이스 부터 구성해서 개발할 경우도 있다.

### 메서드 파라미터와 값 리턴

서비스의 메서드의 인수는 요청 객체 또는 개별 파라미터로 구성할 수 있다. 

- 요청 객체
- 개별 파라미터

요청 파라미터가 두 개 이상 존재하면 요청 객체를 구성하는게 좋다.

응답은 별도의 응답 객체 또는 애그리커트를 반환한다.

- [X] 응답 객체
- [ ] 애그리거트
  - 개발의 편의성
  - 응용 영역과 표현 영역에 분산시킨다. 응집도를 낮추는 원인
  - 기능 실행 로직을 응용 서비스와 표현 영역에 분산시켜 코드의 응집도를 낮추는 원인이 된다.

필요한 데이터만 리턴하는 것이 기능 실행 로직의 응집도를 높이는 확실한 방법이다.

### 표현 영역에 의존하지 않기

응용 서비스의 파라미터 타입을 결정할 때 주의할 점은 표현 영역과 관련된 타입을 사용하면 안 된다.

- 표현 영역의 타입이 있을 경우, 단일 테스트하기 어려워진다.
- 표현 영역이 변경되면 응용 서비스도 함께 변경되어야 한다.

```java
public class RequestVO {

    // 응용 서비스 요청 객체에 표현 영역의 타입을 파라미터로 전달하면 안된다.
    // 표현 영역의 타입
    // private HttpServletRequest request;
    
    // private HttpSession session;
}
```

> 의존성 방향은 항상 고수준 모듈에서 저수준 모듈로 흘러야 한다.

더 나쁜 문제는 응용 서비스가 표현 영역의 역할까지 대신하는 상황이다.

```java
public class AuthenticationService {

    public void authenticate(HttpServletRequest request) {
        String id = request.getParameter("id");
        String password = request.getParameter("password");

        if (checkIdPasswordMatching(id, password)) {
            // 응용 서비스에서 표현 영역의 상태 처리
            HttpSession session = request.getSession();
            session.setAttribute("auth", new Authentication(id));
        }
        
    }
}
```

HttpSession 또는 Cookie 는 표현 영역의 상태다.

- 표현 영역의 응집도가 깨진다.
  - 응용 서비스에서 표현 영역의 상태를 변경하면 표현 영역의 코드만으로 표현 영역의 상태가 어떻게 변경되는지 이해하기 어려워진다.
- 유지 보수 비용을 증가시키는 원인이 된다.

### 트랜잭션 처리

트랜잭션을 관리하는 것은 응용 서비스의 중요한 역할이다.

스프링 프레임워크에서 제공하는 @Transactional 어노테이션을 적극 활용하자.

> 스프링의 기본 동작은 @Transactional 메서드에서 RuntimeException 이 발생하면 트랜잭션을 롤백하고 그렇지 않으면 커밋한다.

### 도메인 이벤트 처리

응용 서비스의 역할 중 하나는 도메인 영역에서 발생시킨 이벤트를 처리하는 것이다.

- 이벤트란 도메인에서 발생한 상태 변경을 의미한다.
- 응용 서비스는 도메인에서 발생한 이벤트를 받아서 처리한다.
  - 이벤트 핸들러를 구성한다.
- 이벤트를 사용하면 코드가 다소 복잡해지는 대신 도메인 간의 의존성을 외부 시스템에 대한 의존을 낮춰주는 장점을 얻을 수 있다.
- 시스템을 확장하는 데에 이벤트가 핵심 역할을 수행하게 된다.

```java
public class Member {

    private Password password;

    public void initializePassword() {
        String newPassword = generateRandomPassword();
        this.password = new Password(newPassword);
        
        // 이벤트 발생
        Events.raise(new PasswordChangedEvent(this.id, password));
    }

}
```

## 표현 영역

표현 영역의 책임은 크게 다음과 같다.

- 사용자가 시스템을 사용할 수 있는 (화면) 흐름을 제공하고 제어한다.
- 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다.
- 사용자의 세션을 관리한다.

## 값 검증

값 검증은 표현 영역과 응용 서비스 두 곳에서 모두 수행할 수 있다.

- 표현 영역: 필수 값, 값의 형식, 범위 등을 검증
- 응용 서비스: 데이터의 존재 유무와 같은 논리적 오류를 검증
  - 응용 서비스를 실행하는 주체가 다양하면 응용 서비스에서 반드시 파라미터로 전달받은 값이 올바른지 검사해야 한다.

원천적으로 모든 값에 대한 검증은 응용 서비스에서 처리한다.

> 기본적으로 요청 파라미터 검증은 응용 영역에서 이뤄진다.

이외에도 표현 영역에서 사용자에게 에러 메시지를 보여주기 위한 용도로 Errors, BindingResult를 사용한다.

표현 영영에서 값 검증은 사용자가 요청한 모든 값을 검증후 잘못된 부분을 에러 메시지로 반환해주기 때문에 사용자의 불편을 해소할 수 있다. 

```java

@Controller
public class Controller {

    @RequestMapping
    public String join(JoinRequest request, Erros erros) {
        checkEmpty(request.getId(), "id", erros);
        checkEmpty(request.getName(), "name", erros);
        // 나머지 값 검증 ...
        
        // 모든 값의 형식을 검증한 뒤, 에러가 존재하면 다시 폼을 보여줌
        if (erros.hasErros()) {
            return formView;
        }
        
        // ...
    }

}
```

## 권한 검사

'사용자 U가 기능 F를 실행할 수 있는지' 확인하는 것이 권한 검사이다.

- 권한 검사 복잡도는 개발할 시스템마다 다르다.
- 유연하고 확장 가능한 사용자 권한 검사 프레임 워크
  - 스프링 시큐리티
  - 아파치 Shiro

일반적으로 다음의 세 곳에서 권한 검사를 수행할 수 있다.

- 표현 영역
  - 인증된 사용자인지 검증
    - 서블릿 필터를 활용한 사용자 검증
    - 인증된 사용자의 웹 요청만 컨트롤러에 전달한다.
    - 인증된 사용자가 아닌 경우 로그인 화면으로 리다이렉트시킨다.
- 응용 서비스
  - URL 만으로 접근 제어를 할 수 없는 경우 응용 서비스으 메서드 단위로 권한 검사를 수행해야 한다.
  - @PreAuthorize
- 도메인
  - 개별 도메인 단위로 권한 검사를 해야 하는 경우는 다소 구현이 복잡해진다.
  - ex) 본인이 작성한 글만 삭제해야 한다.
    - 애그리거트를 조회해서 본인이 작성자인지 권한 검증 

## 조회 전용 기능과 응용 서비스

**조회 전용 기능**을 사용하면 서비스에서 단순히 리포지터리 영역을 호출하면 된다.

서비스에서 수행하는 추가적인 로직이 없을뿐더러 조회 전용 기능이어서 트랜잭션이 필요하지도 않다.

이런 경우라면 굳이 서비스를 만들 필요 없이 표현 영역에서 바로 조회 전용 기능을 사용해도 된다.

- 컨트롤러
  - 조회 전용 기능(DAO/리포지터리)

> CQRS (Command and Query Responsibility Segregation, 명령과 조회의 책임 분리)
