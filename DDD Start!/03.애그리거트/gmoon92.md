# 3장 애그리거트

- [애그리거트](#애그리거트)
- [애그리거트 루트](#애그리거트-루트)
- [도메인 규칙과 일관성](#도메인-규칙과-일관성)
    - [애그리거트 루트의 기능 구현](#애그리거트-루트의-기능-구현)
    - [트랜잭션 범위](#트랜잭션-범위)
- [리포지터리와 애그리거트](#리포지터리와-애그리거트)
- [ID를 이용한 애그리거트 참조](#ID를-이용한-애그리거트-참조)
- [ID를 이용한 참조와 조회 성능](#ID를-이용한-참조와-조회-성능)
- [애그리거트 간 집합 연관](#애그리거트-간-집합-연관)
- [애그리거트를 팩토리로 사용하기](#애그리거트를-팩토리로-사용하기)

## 애그리거트

애그리거트는 도메인 모델의 상위 수준 개념이다.

- 도메인 모델의 전반적인 관계를 이해하는 데 있어, 애그리거트(상위 수준 개념)을 이용해 전체 모델을 정리한다.
- 도메인 모델의 개별 구성요소 위주로 이해하면, 전반적인 시스템의 구조를 파악하기 어렵다.
- 큰 수준에서 도메인 간의 관계를 파악해야 한다.
- 주요 도메인 개념 간의 관계를 파악하는데 용이하다.
    - 장기적인 관점에서 코드 유지보수 및 코드 수정과 기능 확장성에 도움이 된다.

애그리거트는 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 구성하는 과정이다.

- 모델의 일관성을 관리하는 기준이된다.
- 복잡한 모델 관계를 단순한 구조로 만들어준다.
- 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 노력도 줄어든다.

개별 애그리거트는 관련된 모델을 하나로 모은 것이기 때문에, 유사하거나 동일한 라이프사이클을 갖는다.

- 애그리거트에 속한 구성요소는 대부분 함께 생성하고 함께 제거한다.

애그리거트는 경계를 갖는다.

- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
- 애그리거트는 독립된 객체 군이다.
- 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.
- 기본적으로 경계를 설정할 때 도메인 규칙과 요구사항을 기반으로 설정한다.
    - A가 B를 갖는다.
    - 함께 생성되고 변경된다.
    - 도메인을 변경할 때, 함께 변경되는 도메인을 한 애그리거트에 묶는다.
    - 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.
- 동일한 라이프사이클이 아니라면 다른 애그리거트에 속할 가능성이 있다.

## 애그리거트 루트

애그리거트 루트는 애그리거트의 전체 상태를 관리할 주체다.

- 애그리거트 루트는 애그리거트에 속한 객체를 직간접적으로 포함한다.
- 도메인 규칙을 지켜 데이터 일관성을 유지해야한다.
- 애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이어서는 안 된다.
- 규칙을 지키려면, 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.
- 애그리거트 루트는 애그리거트에 속한 모든 객체가 일관된 상태를 유지하기 위함이다.

## 도메인 규칙과 일관성

애그리거트 루트가 단순히 애그리거트에 속한 객체를 포함하는 것으로 끝나는 것은 아니다.

애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.

- 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구한한다.
- 제공하는 도메인 기능은 도메인 규칙을 기반으로 한다.
- 애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다.
    - 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다.
    - 중복 코드 구현 위험 가능성을 높힌다.

불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해 다음 두 가지를 습관적으로 적용해야 한다.

- 단순히 필드를 변경하는 setter 메서드를 공개(public) 범위로 만들지 않는다.
- 밸류 타입은 불변으로 구현한다.

애그리거트 루트 외부에서 애그리거트 상태를 변경할 수 없도록 제약해야 한다.

- 애그리거트 루트가 도메인 규칙을 올바르게만 구현하면 애그리거트 전체의 일관성을 올바르게 유지할 수 있다.

### 애그리거트 루트의 기능 구현

애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.

- 애그리거트 객체에 책임을 위임하는 방식으로 객체간 협력하여 기능 구현한다.
- 외부 변경을 제약하기 위해 불변 객체로 정의하거나, 하나의 패키지에서만 통제되도록 접근 제한자를 구성할 수 있다.

### 트랜잭션 범위

트랜잭션 범위는 작을 수록 좋다.

- DB 테이블을 기준으로 한 트랜잭션이 한 개 테이블을 수정하는 것이 성능상 좋다.
- 동일하게 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.
    - 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 더 높아진다.
- 한 트랜잭션에서 한 애그리거트만 수정한다는 것은 애그리거트에서 다른 애그리거트를 변경하지 않는다는 뜻이다.
- 부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면 응용 계층(서비스)에서 두 애그리거트를 수정하도록 구현해야 한다.
    - 애그리거트에서 다른 애그리거트를 직접 수정하지 않는다.

한 트랜잭션에서 두 개 이상의 애그리거트를 변경하는 것을 고려할 수 있다.

- 팀 표준: 팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 겅우, 또는 DB가 다른 경우 글로벌 트랜잭션을 반드시 사용하도록 규칙을 정하는 곳도 있다.
- 기술 제약: 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하는 대신 도메인 이벤트와 비동기를 사용하는 방식을 사용하는 데, 기술적으로 이벤트 방식을 도입할 수 없는 경우 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 처리해야 한다.
- UI 구현의 편리: 운영자의 편리함을 위해, 기획상 다른 애그리거트를 한번에 변경해야 되는 경우

## 리포지터리와 애그리거트

애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.

- 애그리거트 루트의 리포지토리만 존재한다.
- 루트 엔티티와 연관된 각각의 엔티티가 별도의 테이블에 저장한다고 각각의 리포지터리를 구현하지 않는다.

애그리거트 루트 리포지터리는 적어도 다음 두 메서드를 제공한다.

- save: 애그리거트 저장
- findById: 애그리거트 루트 식별자로 애그리거트 조회

애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야 한다.

- 데이터의 일관성을 유지하기 위해 애그리거트에 속한 전체 엔티티를 조회할 수 있어야 한다.
- RDBMS 를 이용한 리포지토리는 트랜잭션을 이용해서 애그리거트의 변경이 저장소에 반영되는 것을 보장할 수 있다.

## ID를 이용한 애그리거트 참조

한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조한다.

애그리거트의 관리 주체가 애그리거트 루트이므로 애그리거트가 다른 애그리거트를 참조한다는 것은 애그리거트의 루트를 참조한다는 의미다.

```java
class Order {

    // 회원 애그리거트 루트인 Member 객체 참조
    private Member member;
} 
```

하지만 필드를 이용한 애그리거트 참조는 다음 문제를 야기할 수 있다.

- 편한 탐색 오용
- 성능에 대한 고민
- 확장 어려움

애그리거트간의 직접 참조 대신 ID를 이용한 간접 참조를 해야한다.

- 각 애그리거트는 자신의 라이프사이클을 관리한다. 다른 애그리거트의 변경을 관리하지 않는다.
- 트랜잭션 범위는 작게 설정한다.
    - 각 애그리거트당 하나의 트랜잭션 범위로 지정한다.
- 애그리거트 간의 의존 결합도를 높힌다.
- JPA의 객체 그래프 탐색으로 인해 글로벌 패치 전략(lazy, eager)을 고려해야 한다.
- 확장의 문제
    - 트래픽 증가로 인해, 특정 애그리거트를 시스템적으로 분리해야할 경우, 각 애그리거트의 인프라스트럭처 구현 기능이 달라질 가능성이 있다.
        - 예를 들어 몽고DB 를 사용하는 경우, 오라클 또는 MySql을 사용하는 프로젝트 등등

```java
class Order {

    // 회원 애그리거트 루트 ID 로 식별
    private MemberId memberId;
}

class Member {

    private MemberId id;
} 
```

루트 엔티티 간의 간접적 참조는 DB 테이블에서 외래키를 사용해서 참조하는 것과 유사하다.

> 단 애그리거트 내의 객체는 객체로 직접 참조한다.

- 애그리거트의 경계를 명확히 한다.
- 애그리거트 간 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춰준다.
- 애그리거트 간의 의존을 제거하므로 응집도를 높여준다.
- 구현의 복잡도도 낮아진다.
    - JPA의 글로벌 패치 전략을 고민할 필요가 없다.
    - 응용 계층에서 참조할 다른 애그리거트 루트를 조회하면 된다.
    - 필요한 애그리거트를 사용하는 시점에 조회함으로 지연 로딩의 효과와 동일하다.
- 애그리거트 간의 의존도가 낮음으로 복잡도를 낮추는 것과 함께 다른 애그리거트를 직접 수정하는 문제를 원천적으로 방지할 수 있다.
- 각각의 애그리거트는 다른 인프라스트럭츠 계층으로 구성할 수 있다.

## ID를 이용한 참조와 조회 성능

ID 를 통한 다른 애그리거트 루트 엔티티의 간접 참조는 지연 로딩처럼 N+1 조회 문제를 직면한다.

N+1 조회와 같은 문제가 발생하지 않도록 하려면 `전용 조회 쿼리`를 사용하면 된다.

- DAO 를 활용한 네이티브 쿼리 또는 QueryDsl 활용
- 캐시 적용
- 조회 전용 저장소 구성

단. 애그리거트마다 서로 다른 저장소를 사용하는 경우에는 한 번의 쿼리로 관련 애그리거트를 조회할 수 없다.

이런 경우 조회 성능을 높이기 위해 캐시를 적용하거나, 조회 전용 저장소를 따로 구성한다. 이 방법은 코드가 복잡해지는 단점이 있지만 시스템의 처리량을 높일 수 있다는 장점이 있다.

> 특히 한 대의 DB 장비로 대응할 수 없는 수준의 트래픽이 발생하는 경우 캐시나 조회 전용 저장소는 필수로 선택해야 하는 기법이다.

## 애그리거트 간 집합 연관

애그리거트 간의 1:N, M:N 연관에 대한 부분이다.

```java
public class Category {

    private Set<Product> products;

    public List<Product> getProducts(int page, int size) {
        LIst<Product> sortedProducts = sortById(products);
        return sortedProducts.subList((page - 1) * size, page * size);
    }
}
```

- 두 연관은 컬렉션을 이용한 연관이다.
- 성능상 문제가 된다.
- 애그리거트 간에 1:N 연관이 있더라도 이런 성능상의 문제 때문에 애그리거트 간의 1:N 연관을 실제 구현에 반영하는 경우는 드물다.

카테고리에 속한 상품을 구할 필요가 있다면 상품 입장에서 자신이 속한 카테고리를 N:1 로 연관지어 구하면 된다.

- 성능 이슈로 단방향으로 N:1 로 구현해야 한다.

```java
public class Product {

    // 성능 이슈로 조회 주체가 상품으로 변경
    // 1:N이 아닌 단방향으로 N:1 로 설계
    private CategoryId category;
}

public class ProductListService {

    public Page<Product> getProductOfCategory(Long categoryId, int page, int size) {
        Category category = categoryRepository.findById(categoryId);
        checkCategory(category);

        List<Product> products = productRepository.findByCategoryId(category.getId(), page, size);
        int totalCount = productRepository.countByCategoryId(category.getId());
        return new Page(page, size, totalCount, products);
    }

}
```

M:N 연관 구현은 조인 테이블을 활용하여 구현한다.

```java

@Entity
@Table(name = "product")
public class Product {

    @EmbeddedId
    private ProductId id;

    @ElementCollection
    @CollectionsTable(name = "product_category",
            joinColumns = @JoinColumn(name = "product_id"))
    private Set<CategoryId> categoryIds;
}
```

## 애그리거트를 팩토리로 사용하기

응용 계층엔 도메인의 중요한 로직을 반영하지 않는다.

- 논리적으로 하나의 도메인 기능인데 응용 서비스에 구현하는 것이다.
- 별도의 도메인 서비스나 팩토리 클래스를 구현한다.
- 도메인의 응집도를 높힌다.

```java
public class Store extends Member {

    public Product createProduct(ProductId newProductId, ...) {
        if (isBlocked()) {
            throw new StoreBlockedException();
        }

        return new Product(newProductId, getId(),...);
    }
}
```
